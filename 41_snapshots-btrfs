#! /usr/bin/env bash
#
#
#########################################################################################################################################################################
# Written by: Antynea																			#
# BTC donation address: 1Lbvz244WA8xbpHek9W2Y12cakM6rDe5Rt														#
#																					#
# Purpose: Include btrfs snapshots at boot options (grub-menu).														#
#																					#
# What this script does:																		#
# Simple rollback using snapshots you made previously.															#
# - Automatically List snapshots existing on root partition (btrfs).													#
# - Automatically Detect if "/boot" is in separate partition.														#
# - Automatically Detect kernel, initramfs and intel microcode in "/boot" directory on snapshots. (For custon name, see below.)						#
# - Automatically Create corresponding "menuentry" in grub.cfg , which ensures a very easy rollback.									#
# - Automatically detect snapper and use snapper's snapshot description if available.											#
#																					#
# How to use it:																			#
# - Add this lines to /etc/default/grub:																#
#																					#
# * GRUB_BTRFS_SUBMENUNAME="Arch Linux snapshots" 															#
#	(Name appearing in the Grub menu.)																#
# * GRUB_BTRFS_PREFIXENTRY="Snapshot:"        		   														#
#	(Add a name ahead your snapshots entries in the Grub menu.) 													#
# * GRUB_BTRFS_DISPLAY_PATH_SNAPSHOT="true"																#
#	(Show full path snapshot or only name in the Grub menu)														#
# * GRUB_BTRFS_TITLE_FORMAT="p/d/n"																	#
#	(Custom title, shows/hides p"prefix" d"date" n"name" in the Grub menu, separator "/", custom order available)							#
# * GRUB_BTRFS_LIMIT="100"																		#
#	(Limit the number of snapshots populated in the GRUB menu.)													#
# * GRUB_BTRFS_SUBVOLUME_SORT="descending"																#
#	(Sort the found subvolumes by newest first ("descending") or oldest first ("ascending").									#
#	If "ascending" is chosen then the $GRUB_BTRFS_LIMIT oldest subvolumes will populate the menu.)									#
# * GRUB_BTRFS_SHOW_SNAPSHOTS_FOUND="true"																#
#	(Show snapshots found during run "grub-mkconfig")														#
# * GRUB_BTRFS_SHOW_TOTAL_SNAPSHOTS_FOUND="true"															#
#	(Show Total of snapshots found during run "grub-mkconfig")													#
# * GRUB_BTRFS_NKERNEL=("vmlinuz-linux") 		 														#
#	(Use only if you have custom kernel name or auto-detect failed.)												#
# * GRUB_BTRFS_NINIT=("initramfs-linux.img" "initramfs-linux-fallback.img")												#
#	(Use only if you have custom initramfs name or auto-detect failed.)												#
# * GRUB_BTRFS_INTEL_UCODE=("intel-ucode.img") 																#
#	(Use only if you have custom intel-ucode or auto-detect failed.)		    										#
# * GRUB_BTRFS_IGNORE_SPECIFIC_PATH=("var/lib/docker" "nosnapshot")													#
#	(Ignore specific path during run "grub-mkconfig")														#
# * GRUB_BTRFS_CREATE_ONLY_HARMONIZED_ENTRIES="false"															#
#	(Create entries with matching version number instead of all possible combinations of kernel and initramfs)							#
# * GRUB_BTRFS_SNAPPER_CONFIG="root"															#
#	(Snapper's config name to use)							#
#																					#
# - Generate grub.cfg (on Arch Linux use grub-mkconfig -o /boot/grub/grub.cfg)												#
#																					#
# - grub-btrfs automatically generates snapshots entries.														#
# - You will see it appear different entries (e.g : Snapshot: [2014-02-12 11:24:37] my snapshot name overkill)								#
#																					#
# Automatically update grub																		#
#  If you would like grub to automatically update when Snapper timeline snapshots and cleanups occur, simply install 10-update_grub.conf in the following locations:	#
# - /etc/systemd/system/snapper-timeline.service.d/															#
# - /etc/systemd/system/snapper-cleanup.service.d/															#
# Once the configuration files are in place, systemctl daemon-reload should be run to reload the units and make the changes active.					#
#																					#
#########################################################################################################################################################################

set -e

#prefix="/usr"
#exec_prefix="${prefix}"
datarootdir="/usr/share"
#datadir="${datarootdir}"
sysconfdir="/etc"

. "${datarootdir}/grub/grub-mkconfig_lib"
. "${sysconfdir}/default/grub"

######################################
### Variables in /etc/default/grub ###
######################################
## Submenu name
submenuname=${GRUB_BTRFS_SUBMENUNAME:-"Arch Linux snapshots"}
## Prefix entry
prefixentry=${GRUB_BTRFS_PREFIXENTRY:-"Snapshot:"}
## Show full path snapshot or only name
path_snapshot=${GRUB_BTRFS_DISPLAY_PATH_SNAPSHOT:-"true"}
## Title format
title_format=${GRUB_BTRFS_TITLE_FORMAT:-"p/d/n"}
## Kernel(s) name(s)
nkernel=("${GRUB_BTRFS_NKERNEL[@]}")
## Initramfs name(s)
ninit=("${GRUB_BTRFS_NINIT[@]}")
## Microcode(s) name(s)
microcode=("${GRUB_BTRFS_INTEL_UCODE[@]}")
## Limit to show in the Grub menu
limit_snap_show="${GRUB_BTRFS_LIMIT:-100}"
## How to sort snapshots list
snap_list_sort=${GRUB_BTRFS_SUBVOLUME_SORT:-"descending"}
case "${snap_list_sort}" in
    ascending)          btrfssubvolsort=("--sort=+rootid");;
    *)                  btrfssubvolsort=("--sort=-rootid")
esac
## Show snapshots found during run "grub-mkconfig"
show_snap_found=${GRUB_BTRFS_SHOW_SNAPSHOTS_FOUND:-"true"}
## Show Total of snapshots found during run "grub-mkconfig"
show_total_snap_found=${GRUB_BTRFS_SHOW_TOTAL_SNAPSHOTS_FOUND:-"true"}
## Ignore specific path during run "grub-mkconfig"
ignore_specific_path=("${GRUB_BTRFS_IGNORE_SPECIFIC_PATH[@]}")
## create only entries with harmonized version numbers
harmonized_entries=${GRUB_BTRFS_CREATE_ONLY_HARMONIZED_ENTRIES:-"false"}
## snapper's config name
snapper_config=${GRUB_BTRFS_SNAPPER_CONFIG:-"root"}


########################
### variables script ###
########################
## Internationalization (default : english)
export TEXTDOMAIN=grub-btrfs-git
export TEXTDOMAINDIR="/usr/share/locale"
## hints string
hs_boot=$(${grub_probe} --target="hints_string" "/boot" 2>/dev/null)
## UUID of the boot partition
boot_uuid=$(${grub_probe} --target="fs_uuid" "/boot" 2>/dev/null)
## Type filesystem of boot partition
boot_fs=$(${grub_probe} --target="fs" "/boot" 2>/dev/null)
## UUID of the root partition
root_uuid=$(${grub_probe} "/" --target="fs_uuid" 2>/dev/null)
## Parameters passed to the kernel
kernel_parameters="$GRUB_CMDLINE_LINUX $GRUB_CMDLINE_LINUX_DEFAULT"
## Mount point location
gbgmp=$(mktemp -d)
## Class for theme
CLASS="--class snapshots --class gnu-linux --class gnu --class os"
## save IFS
oldIFS=$IFS
## boot_dir (auto-detect if /boot is separate partition or not)
boot_dir()
{
	boot_dir="$gbgmp/$snap_dir_name/boot"
	[[ "$root_uuid" != "$boot_uuid" ]] && boot_dir="/boot"
	echo "$boot_dir"
}


##############
### Script ###
##############

### BEGIN auto detect ###

## menu entries
snapshots_entry()
{
## \" required for snap,kernels,init,microcode with space in their name
	echo "	submenu '$title_menu' {
		submenu '---> $title_menu <---' { echo }
	"
	for k in "${name_kernel[@]}"; do
		for i in "${name_initramfs[@]}"; do
			for u in "${name_microcode[@]}"; do
			if [ -f "$(boot_dir)"/"${u}" ] ; then
				echo "\
		menuentry '"${k}" & "${i}" & "${u}"' ${CLASS} "\$menuentry_id_option" 'gnulinux-snapshots-$boot_uuid'{"
			else 
				echo "\
		menuentry '"${k}" & "${i}"' ${CLASS} "\$menuentry_id_option" 'gnulinux-snapshots-$boot_uuid'{"
			fi
			echo "\
			$(save_default_entry)
			if [ x\$feature_all_video_module = xy ]; then
				insmod all_video
			fi
			set gfxpayload=keep
			insmod ${boot_fs}
			if [ x\$feature_platform_search_hint = xy ]; then
				search --no-floppy --fs-uuid  --set=root ${hs_boot} ${boot_uuid}
			else
				search --no-floppy --fs-uuid  --set=root ${boot_uuid}
			fi
			echo 'Loading Snapshot: "${snap_date_time}" "${snap_dir_name}"'
			echo 'Loading Kernel: "${k}" ...'
			linux \"${boot_dir_real_path}/"${k}"\" root=UUID=${root_uuid} rw rootflags=subvol=\""${snap_dir_name}"\" ${kernel_parameters}"
			if [ -f "$(boot_dir)"/"${u}" ] ; then
				echo "\
			echo 'Loading Microcode & Initramfs: "${u}" "${i}" ...'
			initrd \"${boot_dir_real_path}/"${u}"\" \"${boot_dir_real_path}/"${i}"\""
			else
				echo "\
			echo 'Loading Initramfs: "${i}" ...'
			initrd \"${boot_dir_real_path}/"${i}"\""
			fi
		echo "		}"
			done
		done
	done
	echo "	}"
}

harmonized_snapshots_entry()
{
## \" required for snap,kernels,init,microcode with space in their name
	echo "	submenu '$title_menu' {
		submenu '---> $title_menu <---' { echo }
	"
	for k in "${name_kernel[@]}"; do
		version=${k#vmlinuz-}
		i=""
		if [ -f "$(boot_dir)"/initramfs-"${version}".img ]; then
			i=initramfs-${version}.img
		else
			if [ -f "$(boot_dir)"/initrd.img-"${version}" ]; then
				i=initrd.img-${version}
			fi
		fi
		for u in "${name_microcode[@]}"; do
			if [ -f "$(boot_dir)"/"${u}" ] ; then
				echo "\
		menuentry '"${k}" & "${i}" & "${u}"' ${CLASS} "\$menuentry_id_option" 'gnulinux-snapshots-$boot_uuid'{"
			else 
				echo "\
		menuentry '"${k}" & "${i}"' ${CLASS} "\$menuentry_id_option" 'gnulinux-snapshots-$boot_uuid'{"
			fi
			echo "\
			$(save_default_entry)
			if [ x\$feature_all_video_module = xy ]; then
				insmod all_video
			fi
			set gfxpayload=keep
			insmod ${boot_fs}
			if [ x\$feature_platform_search_hint = xy ]; then
				search --no-floppy --fs-uuid  --set=root ${hs_boot} ${boot_uuid}
			else
				search --no-floppy --fs-uuid  --set=root ${boot_uuid}
			fi
			echo 'Loading Snapshot: "${snap_date_time}" "${snap_dir_name}"'
			echo 'Loading Kernel: "${k}" ...'
			linux \"${boot_dir_real_path}/"${k}"\" root=UUID=${root_uuid} rw rootflags=subvol=\""${snap_dir_name}"\" ${kernel_parameters}"
			if [ -f "$(boot_dir)"/"${i}" ] ; then
				if [ -f "$(boot_dir)"/"${u}" ] ; then
					echo "\
			echo 'Loading Microcode & Initramfs: "${u}" "${i}" ...'
			initrd \"${boot_dir_real_path}/"${u}"\" \"${boot_dir_real_path}/"${i}"\""
				else
					echo "\
			echo 'Loading Initramfs: "${i}" ...'
			initrd \"${boot_dir_real_path}/"${i}"\""
				fi
			fi
			echo "		}"
		done
	done
	echo "	}"
}

## Trim a string from leading and trailing whitespaces
trim() {
	local var="$*"
	var="${var#"${var%%[![:space:]]*}"}"
	var="${var%"${var##*[![:space:]]}"}"
	echo -n "$var"
}

## List of snapshots on filesystem
snapshot_list()
{
	# Query info from snapper if it is installed
	type snapper >/dev/null 2>&1
	if [[ $? -eq 0 ]]; then
		local snapper_ids=($(snapper -t 0 -c "$snapper_config" list | tail -n +3 | cut -d'|' -f 2))
		local snapper_types=($(snapper -t 0 -c "$snapper_config" list | tail -n +3 | cut -d'|' -f 1))

		IFS=$'\n'
		local snapper_descriptions=($(snapper -t 0 -c "$snapper_config" list | tail -n +3 | cut -d'|' -f 7))
	fi

	IFS=$'\n'

	# Parse btrfs snapshots
	local entries=()
	local ids=()
	local max_entry_length=0
	for snap in $(btrfs subvolume list -sa "${btrfssubvolsort}" /); do
		IFS=$oldIFS
		snap=($snap)
		local snap_path_name=${snap[@]:13:${#snap[@]}}

		# Discard deleted snapshots
		if [ "$snap_path_name" = "DELETED" ]; then continue; fi
		[[ ${snap_path_name%%"/"*} == "<FS_TREE>" ]] && snap_path_name=${snap_path_name#*"/"}

		### ignore specific path during run "grub-mkconfig"
		if [ ! -z "${ignore_specific_path}" ] ; then
			for isp in ${ignore_specific_path[@]} ; do
				[[ "${snap_path_name}" == "${isp}"/* ]] && continue 2;
			done
		fi

		### detect if /boot directory exists
		[[ ! -d "$gbgmp/$snap_path_name/boot" ]] && continue;

		local id="${snap_path_name//[!0-9]}" # brutal way to get id: remove everything non-numeric
		ids+=("$id")

		local entry="${snap[@]:10:2} | ${snap_path_name}"
		entries+=("$entry")

		# Find max length of a snapshot entry, needed for pretty formatting
		local length="${#entry}"
		[[ "$length" -gt "$max_entry_length" ]] && max_entry_length=$length
	done

	# Find max length of a snapshot type, needed for pretty formatting
	local max_type_length=0
	for id in "${ids[@]}"; do
		for j in "${!snapper_ids[@]}"; do
			local snapper_id="${snapper_ids[$j]//[[:space:]]/}"
			if [[ "$snapper_id" == "$id" ]]; then
				local snapper_type=$(trim "${snapper_types[$j]}")
				local length="${#snapper_type}"
				[[ "$length" -gt "$max_type_length" ]] && max_type_length=$length
			fi
		done
	done

	for i in "${!entries[@]}"; do
		local id="${ids[$i]}"
		local entry="${entries[$i]}"
		for j in "${!snapper_ids[@]}"; do
			local snapper_id="${snapper_ids[$j]//[[:space:]]/}"
			if [[ "$snapper_id" == "$id" ]]; then
				local snapper_type=$(trim "${snapper_types[$j]}")
				local snapper_description=$(trim "${snapper_descriptions[$j]}")
				printf -v entry "%-${max_entry_length}s | %-${max_type_length}s | %s" "$entry" "$snapper_type" "$snapper_description"
				break
			fi
		done
		echo "$entry"
	done

	IFS=$oldIFS
}

## Detect kernels in "/boot"
detect_kernel()
{
	## Arch original kernel (auto-detect)
	for akernel in "$(boot_dir)"/vmlinuz-* ; do 
		list_kernel+=("$akernel")
	done

	## Custom name kernel in GRUB_BTRFS_NKERNEL
	if [ ! -z "${nkernel}" ] ; then
		for ckernel in "${nkernel[@]}" ; do
			[[ ! -f /"$(boot_dir)"/"${ckernel}" ]] && continue;
			list_kernel+=("$ckernel")
		done
	fi
}

## Detect initramfs in "/boot"
detect_initramfs()
{
	## Arch original initramfs (auto-detect)
	for ainitramfs in "$(boot_dir)"/initramfs-* ; do 
		list_initramfs+=("$ainitramfs")
	done
	
	## Custom name initramfs in GRUB_BTRFS_NINIT
	if [ ! -z "$ninit" ] ; then
		for cinitramfs in "${ninit[@]}" ; do
			[[ ! -f /"$(boot_dir)"/"${cinitramfs}" ]] && continue;
			list_initramfs+=("$cinitramfs")
		done
	fi
}

## Detect microcode in "/boot"
detect_microcode()
{
	## Arch original intel microcode
	for aucode in "$(boot_dir)"/intel-ucode.img ; do
		list_ucode+=("$aucode")
	done

	## Custom name microcode in GRUB_BTRFS_INTEL_UCODE
	if [ ! -z "$microcode" ] ; then
		for cucode in "${microcode[@]}" ; do
			[[ ! -f /"$(boot_dir)"/"${cucode}" ]] && continue
			list_ucode+=("$cucode")
		done
	fi
}

## Show full path snapshot or only name
path_snapshot()
{
	case "${path_snapshot}" in
		true) name_snapshot=("${snap_full_name}");;
		*) name_snapshot=("${snap_full_name#*"/"}")
	esac
}

## Title format in grub-menu
title_format()
{
	case "${title_format}" in
		p/d/n) 	title_menu="${prefixentry} ${snap_date_time} ${name_snapshot}";;
		p/n/d) 	title_menu="${prefixentry} ${name_snapshot} ${snap_date_time}";;
		p/d) 	title_menu="${prefixentry} ${snap_date_time}";;
		p/n) 	title_menu="${prefixentry} ${name_snapshot}";;
		d/n) 	title_menu="${snap_date_time} ${name_snapshot}";;
		n/d) 	title_menu="${name_snapshot} ${snap_date_time}";;
		p) 	title_menu="${prefixentry}";;
		d)	title_menu="${snap_date_time}";;
		n)	title_menu="${name_snapshot}";;
		*)	gettext_printf $"# Warning: GRUB_BTRFS_TITLE_FORMAT=${title_format}, syntax error \n" >&2
	esac
}

## List of kernels, initramfs and microcode in snapshots
list_kernels_initramfs()
{
	IFS=$'\n'
	count_limit_snap=0
	for item in $(snapshot_list); do
		### fix: limit_snap_show=0
		[[ ${limit_snap_show} -le 0 ]] && break;
		IFS=$oldIFS
		snap_full_name="$(echo "$item" | cut -d'|' -f2-)" # do not trim it to keep nice formatting
		snap_dir_name="$(echo "$item" | cut -d'|' -f2)"
		snap_dir_name="$(trim "$snap_dir_name")"

		### show snapshot found during run "grub-mkconfig"
		snap_date_time="$(echo "$item" | cut -d' ' -f1-2)"
		snap_date_time="$(trim "$snap_date_time")"
		if [[ "${show_snap_found}" = "true" ]]; then
		gettext_printf $"# Found snapshot: %s\n" "$item" >&2 ;
		fi
		### Kernel (auto-detect + custom kernel)
		unset list_kernel
		detect_kernel
		name_kernel=("${list_kernel[@]##*"/"}")
		# echo "kernel = ${name_kernel[*]}"
		if [[ "${harmonized_entries}" != "true" ]]; then
			### Initramfs (autodetect + custom initramfs)
			unset list_initramfs
			detect_initramfs
			name_initramfs=("${list_initramfs[@]##*"/"}")
			# echo "initramfs = ${name_initramfs[*]}"
		fi
		### microcode (auto-detect + custom microcode)
		unset list_ucode
		detect_microcode
		name_microcode=("${list_ucode[@]##*"/"}")
		# echo "ucode = ${name_microcode[*]}"
		### real path to boot
		boot_dir_real_path="$(make_system_path_relative_to_its_root "$(boot_dir)")"
		### Create menu entries
		## name snapshot
		path_snapshot
		## title menu custom
		title_format
		# echo "${title_menu}"
		if [[ "${harmonized_entries}" = "false" ]]; then
			snapshots_entry
		else
			harmonized_snapshots_entry
		fi
		### Limit snapshots found during run "grub-mkconfig"
	        count_limit_snap=$((1+$count_limit_snap))
	        [[ $count_limit_snap -ge $limit_snap_show ]] && break;
	done
	IFS=$oldIFS
}
### END auto detect ###

### Start ###
	gettext_printf "###### - Grub-btrfs: Auto-detect Start - ######\n" >&2 ;
	### create mount point and mounts
	[[ ! -d $gbgmp ]] && mkdir -p $gbgmp
	mount -o subvolid=5 /dev/disk/by-uuid/$root_uuid $gbgmp/
	### Create a menu in grub
	echo "submenu '${submenuname}' {"
	list_kernels_initramfs ;
	## show total found snapshots
	if [[ "${show_total_snap_found}" = "true" ]]; then
	gettext_printf "# Found ${count_limit_snap} snapshot(s)\n" >&2 ;
	fi
	## if no snapshot found, show a warning 
	if [[ "${count_limit_snap}" = "0" ]]; then
		echo " submenu '---> "No snapshot found : Press ESC to return previous menu" <---' { echo } ";
		gettext_printf "# No snapshot found \n# make sure you have at least one snapshot \n# or please file a bug report at \"https://github.com/Antynea/grub-btrfs\"\n" >&2 ;
	fi
	echo "}"
	## unmount mount point
	umount $gbgmp
	gettext_printf "###### - Grub-btrfs: Auto-detect End   - ######\n" >&2 ;
### End ###
